var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ReferenceImplementations\nDocTestSetup = :(using ReferenceImplementations)","category":"page"},{"location":"#ReferenceImplementations.jl","page":"Home","title":"ReferenceImplementations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ReferenceImplementations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A typical workflow in science involves writing a function twice,","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1: Reference implementation. Since Julia is so expressive, this implementation is usually short and resembles the published equations or pseudocode.\nV2: Optimized implementation. This version is written for computers, i.e. ⊂ { exploits symmetries, reuses allocated memory, hits the cache in a friendly way, reorders calculations for SIMD, divides the work with threads, precomputes parts, caches intermediate expressions, ... }.","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1 is easier to understand and extend. V2 is the implementation exported in your package and it's often much faster, but complicated and verbose. Julia sometimes allows you to use abstractions such that V1 ≈ V2, but this is not always possible. This package lets you define both implementations and select which one is run, even when the function is nested inside other function calls.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @refimpl macro applies a Cassette pass to each  top-level function in the input expression, recursively replacing nested methods that have a reference implementations. Those reference implementations are defined by prefacing a method definition with @refimpl. A single function can be replaced via @refimpl (func) (expression). ","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calling @refimpl on an expression calls every method with a reference implementation in the nested sequence of calls for that expression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ReferenceImplementations\n@refimpl mysin(x) = begin println(\"ref mysin\"); return sin(x) end\nmysin(x) = begin println(\"mysin\"); return sin(x) end\n\n# call the reference implementation\n@refimpl mysin(0.)  # prints \"ref mysin\"\nmysin(0.)           # prints \"mysin\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This works for @refimpl functions that are nested inside other functions in the expression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@refimpl f(x) = begin println(\"ref f\"); return mysin(x)^2 end\nf(x) = begin println(\"f\"); return mysin(x)^2 end\n\n# call the reference implementation\n@refimpl f(0.)  # prints \"ref f\", \"ref mysin\"\nf(0.)           # prints \"f\", \"mysin\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, @refimpl replaces every call in the expression which has a defined reference implementation. It can sometimes be desirable to use the reference implementation of a specific function. This is achieved by providing a function before the expression to be evaluated by @refimpl (func) (expr).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@refimpl mysin f(0.)  # prints \"f\", \"ref mysin\"\n@refimpl f f(0.)      # prints \"ref f\", \"mysin\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using @refimpl does incur some compilation cost, but subsequent calls should be fast. ","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It can be useful to use the macro in your unit tests, where one assumes that the reference implementation is correct and then develops a highly-optimized version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@test func(a, b) == @refimpl func(a, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that a macro's input is the entire expression after it. You should call the macro like a function in order to limit its effect.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@refimpl f(x) = 1x\nf(x) = 2x\n\nprint( @refimpl(f(1)), \", \", f(1) )  # prints 1, 2 ","category":"page"},{"location":"#How?","page":"Home","title":"How?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the @refimpl macro is applied to a method definition, it injects a first argument of type ReferenceImplementations.RefImpl into the signature. This performs the transform","category":"page"},{"location":"","page":"Home","title":"Home","text":"func(args...; kwargs...)  ⇨  func(::ReferenceImplementations.RefImpl, args...; kwargs...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the type signatures preserved (so where and ::T match, for example). When you apply the @refimpl macro to an expression that isn't a function definition, it applies a Cassette pass for each top-level function call in an expression, which replaces func(args...; kwargs...) with func(::ReferenceImplementations.RefImpl, args...; kwargs...) if that method exists. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This also means that you can manually call the reference implementation without the macro, using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ReferenceImplementations: RefImpl\nfunc(RefImpl(), args...; kwargs...)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ReferenceImplementations]","category":"page"},{"location":"#ReferenceImplementations.@refimpl-Tuple{Any}","page":"Home","title":"ReferenceImplementations.@refimpl","text":"@refimpl (method definition)\n@refimpl (expression)\n@refimpl (function name) (expression)\n\nIf prefacing a function definition, defines a reference implementation for that function.\nIf prefacing an expression that isn't a function definition, invokes reference implementations of methods defined with @refimpl, even if nested.\n\nPreface an expression performs a Cassette pass on every top-level function in the expression, recursively looking for methods with @refimpl implementations. If a function is passed before the expression (separated by a space), only that method is switched with its reference implementation.\n\nExamples\n\nCalling @refimpl on an expression calls every method with a reference implementation in the nested sequence of calls for that expression.\n\nusing ReferenceImplementations\n@refimpl mysin(x) = begin println(\"ref mysin\"); return sin(x) end\nmysin(x) = begin println(\"mysin\"); return sin(x) end\n\n# call the reference implementation\n@refimpl mysin(0.)  # prints \"ref mysin\"\nmysin(0.)           # prints \"mysin\"\n\nThis works for @refimpl functions that are nested inside other functions in the expression.\n\n@refimpl f(x) = begin println(\"ref f\"); return mysin(x)^2 end\nf(x) = begin println(\"f\"); return mysin(x)^2 end\n\n# call the reference implementation\n@refimpl f(0.)  # prints \"ref f\", \"ref mysin\"\nf(0.)           # prints \"f\", \"mysin\"\n\nYou can target individual functions to be replaced with their reference implementation by passing that function after @refimpl.\n\n@refimpl mysin f(0.)  # prints \"f\", \"ref mysin\"\n@refimpl f f(0.)      # prints \"ref f\", \"mysin\"\n\n\n\n\n\n","category":"macro"}]
}
