var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Slow","category":"page"},{"location":"#Slow","page":"Home","title":"Slow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Slow. This package attempts to address a tension between understandability and efficiency in scientific computing. A naive Julia implementation of a calculation is often very readable, and resembles published equations or pseudocode. However, an optimized implementation that uses knowledge of how modern CPUs work can be much faster – but it's usually more verbose. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package exports @slowdef to define a slower, naive implementation of a function, and call it with @slow. Here's an example, where we implement a slow version of a function, and a fast version. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Slow\n\n# fake naive implementation\n@slowdef function f(x)\n    sleep(1)  \n    return sin(x)\nend\n\n# fake fast implementation\nfunction f(x)\n    return sin(x)\nend\n\n@time @slow f(1.0)\n@time f(1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function definition func(args...) prefaced by @slowdef is replaced with signature func(::Slow.SlowImplementation, args...). This is a shortcut for a common Julia multimethod pattern, where different implementations dispatch on the first argument. I think the magic number here is two (fast and slow) – if you have three or more implementations, you should probably just define your own multimethod type. This macro can help with development too – one common pattern of writing code is to first make it correct, and then make it fast. By keeping separate fast and @slow implementations, one can more easily resist premature optimization and micro-optimizations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're using the slow version in a complicated expression, you should use the macro @slow like a function and wrap the function call in parentheses, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@slow(f(1.0)) + 1.0","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Slow]","category":"page"},{"location":"#Slow.@slow-Tuple{Any}","page":"Home","title":"Slow.@slow","text":"@slow\n\nCall a slow version of a function that was defined with @slowdef. ```\n\n\n\n\n\n","category":"macro"},{"location":"#Slow.@slowdef-Tuple{Any}","page":"Home","title":"Slow.@slowdef","text":"@slowdef\n\nDefine a slow version of a function which can be called with @slow.\n\n\n\n\n\n","category":"macro"},{"location":"#Slow.@slowtest-Tuple{Any}","page":"Home","title":"Slow.@slowtest","text":"@slowtest\n\nShortcut for @test (@slow func(args...)) == func(args...).\n\n\n\n\n\n","category":"macro"}]
}
