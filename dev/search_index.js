var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SlowMacro\nDocTestSetup = :(using SlowMacro)","category":"page"},{"location":"#SlowMacro.jl","page":"Home","title":"SlowMacro.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SlowMacro.jl. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package exports @slowdef to define a slower, naive implementation of a function, and  change it (even when it's buried in some other function) using the @slow macro. It does  this by performing a Cassette pass on every top-level function call in the expression provided to the macro.","category":"page"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I often write two versions of a function,","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1: Naive implementation. Since Julia is so expressive, this implementation is usually short and resembles the published equations or pseudocode.\nV2: Optimized implementation. This version is written for a computer, i.e. ⊂ { exploits symmetries, reuses allocated memory, hits the cache in a friendly way, reorders calculations for SIMD, divides the work with threads, precomputes parts, caches intermediate expressions, ... }.","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1 is easier to understand and extend. V2 is the implementation exported in your package and it's often much faster, but complicated and verbose. Julia sometimes allows you to use abstractions such that V1 ≈ V2, but this is not always possible. SlowMacro.jl lets you keep both, and toggle them even when they're deeply nested.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's an example, where we implement a slow version of a function, and a fast version. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SlowMacro\n\n# fake naive implementation\n@slowdef function f(x)\n    println(\"slow f\")\n    return sin(x)\nend\n\n# fake fast implementation\nfunction f(x)\n    println(\"fast f\")\n    return sin(x)\nend\n\nf(0.0)\n\n# output\n\nfast f\n0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running f(0.0) just uses the definition we gave for it. However, @slow f(0.0) will go to the @slowdef version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@slow f(0.0)\n\n# output\n\nslow f\n0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function definition func(args...), when prefaced by @slowdef, instead defines a function with signature func(::SlowMacro.SlowImplementation, args...). Use of func can now  be toggled between the slow and fast implementations, for arbitrary nesting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> h(x) = f(x)^2 + cos(x)^2\nh (generic function with 1 method)\n\njulia> h(1.0)\nfast f\n1.0\n\njulia> @slow h(1.0)\nslow f\n0.0","category":"page"},{"location":"#Single-Function-Selection","page":"Home","title":"Single Function Selection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By default, @slow slows every function involved in the expression which has a slow implementation in the caller's module.  It can sometimes be desirable to slow down a specific function. This is achieved by providing a function before the expression to be evaluated by @slow func (expr).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @slowdef s(x) = begin println(\"slow s\"); return sin(x) end\n       s(x) = sin(x)\n       @slowdef c(x) = begin println(\"slow c\"); return cos(x) end\n       c(x) = cos(x)\n       h(x) = s(x)^2 + c(x)^2;\n\njulia> @slow s h(0.5)\nslow s\n1.0\n\njulia> @slow c h(0.5)\nslow c\n1.0\n\njulia> @slow h(0.5)\nslow s\nslow c\n1.0","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SlowMacro]","category":"page"},{"location":"#SlowMacro.@slow-Tuple{Any}","page":"Home","title":"SlowMacro.@slow","text":"@slow (expr)\n@slow (func) (expr)\n\nCall a slow version of a function that was defined with @slowdef. Preface an expression in order to perform a Cassette pass on every top-level function in the expression, recursively looking for functions with @slowdef implementations. If a function is passed before the expression (separated by a space), only that function is slowed.\n\nExamples\n\nCalling @slow on an expression calls every function with a slow implementation in the nested sequence of calls for that expression.\n\n@slowdef s(x) = begin println(\"slow s\"); return sin(x) end\ns(x) = begin println(\"fast s\"); return sin(x) end\n\n# call the slow version\n@slow s(0.)  # prints \"slow s\"\ns(0.)        # prints \"fast s\"\n\nThis works for slow functions that are nested inside other functions in the expression.\n\n@slowdef f(x) = begin println(\"slow f\"); return s(x)^2 end\nf(x) = begin println(\"fast f\"); return s(x)^2 end\n\n# call the slow version\n@slow f(0.)  # prints \"slow f\", \"slow s\"\nf(0.)        # prints \"fast f\", \"fast s\"\n\nYou can target individual functions for slowing by passing a function after SlowMacro.\n\n@slow s f(0.)  # prints \"fast f\", \"slow s\"\n@slow f f(0.)  # prints \"slow f\", \"fast s\"\n\n\n\n\n\n","category":"macro"},{"location":"#SlowMacro.@slowdef-Tuple{Any}","page":"Home","title":"SlowMacro.@slowdef","text":"@slowdef [function definition]\n\nDefine a slow version of a function which can be called with @slow. To use, preface a method definition with this macro.\n\nExamples\n\nusing SlowMacro\n\n# define a slow version of x\n@slowdef f(x) = println(\"slow\")\nf(x) = println(\"fast\")\n\n@slow f(0.0)  # prints \"slow\"\nf(0.0)        # prints \"fast\"\n\n# you can also use the full function definition form, of course\n@slowdef function g(x::T) where T\n    return x\nend\n\n\n\n\n\n","category":"macro"}]
}
