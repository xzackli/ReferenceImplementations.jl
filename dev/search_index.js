var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ReferenceImplementations\nDocTestSetup = :(using ReferenceImplementations)","category":"page"},{"location":"#ReferenceImplementations.jl","page":"Home","title":"ReferenceImplementations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ReferenceImplementations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package exports @refimpl to define a reference implementation of a function, and call it (even when it's buried in some other function) using the @refimpl macro. It does this by performing a Cassette pass on every top-level function call in the expression provided to the macro.","category":"page"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I often write two versions of a function,","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1: Naive implementation. Since Julia is so expressive, this implementation is usually short and resembles the published equations or pseudocode.\nV2: Optimized implementation. This version is written for a computer, i.e. ⊂ { exploits symmetries, reuses allocated memory, hits the cache in a friendly way, reorders calculations for SIMD, divides the work with threads, precomputes parts, caches intermediate expressions, ... }.","category":"page"},{"location":"","page":"Home","title":"Home","text":"V1 is a reference implementation that is correct, easy to understand, and easy to extend. V2 is the implementation exported in your package and it's often much faster, but complicated and verbose. Julia sometimes allows you to use abstractions such that V1 ≈ V2, but this is not always possible. ReferenceImplementations.jl lets you keep both, and toggle them even when they're deeply nested.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's an example, where we implement a reference implementation of a function, and a fast version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ReferenceImplementations\n\n# fake naive implementation\n@refimpl function f(x)\n    println(\"ref f\")\n    return sin(x)\nend\n\n# fake fast implementation\nfunction f(x)\n    println(\"f\")\n    return sin(x)\nend\n\nf(0.0)\n\n# output\n\nf\n0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running f(0.0) just uses the definition we gave for it. However, @refimpl f(0.0) will go to the reference implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@refimpl f(0.0)\n\n# output\n\nref f\n0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function definition func(args...), when prefaced by @refimpl, instead defines a function with signature func(::ReferenceImplementations.RefImpl, args...). Use of func can now be be substituted with the reference implementation, even when the calls are nested in other functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> h(x) = f(x)^2 + cos(x)^2\nh (generic function with 1 method)\n\njulia> h(1.0)\nf\n1.0\n\njulia> @refimpl h(1.0)\nref f\n0.0","category":"page"},{"location":"#Single-Function-Selection","page":"Home","title":"Single Function Selection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By default, @refimpl replaces every call in the expression which has a defined reference implementation. It can sometimes be desirable to use the reference implementation of a specific function. This is achieved by providing a function before the expression to be evaluated by @refimpl (func) (expr).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @refimpl s(x) = begin println(\"ref s\"); return sin(x) end\n       s(x) = sin(x)\n       @refimpl c(x) = begin println(\"ref c\"); return cos(x) end\n       c(x) = cos(x)\n       h(x) = s(x)^2 + c(x)^2;\n\njulia> @refimpl s h(0.5)\nref s\n1.0\n\njulia> @refimpl c h(0.5)\nref c\n1.0\n\njulia> @refimpl h(0.5)\nref s\nref c\n1.0","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ReferenceImplementations]","category":"page"},{"location":"#ReferenceImplementations.@refimpl-Tuple{Any}","page":"Home","title":"ReferenceImplementations.@refimpl","text":"@refimpl (method definition)\n@refimpl (expression)\n@refimpl (function name) (expression)\n\nIf prefacing a function definition, defines a reference implementation for that function.\nIf prefacing an expression, calls reference implementations of methods defined with @refimpl.\n\nPreface an expression performs a Cassette pass on every top-level function in the expression, recursively looking for methods with @refimpl implementations. If a function is passed before the expression (separated by a space), only that method is switched with its reference implementation.\n\nExamples\n\nCalling @refimpl on an expression calls every method with a reference implementation in the nested sequence of calls for that expression.\n\nusing ReferenceImplementations\n@refimpl mysin(x) = begin println(\"ref mysin\"); return sin(x) end\nmysin(x) = begin println(\"mysin\"); return sin(x) end\n\n# call the reference implementation\n@refimpl mysin(0.)  # prints \"ref mysin\"\nmysin(0.)        # prints \"mysin\"\n\nThis works for @refimpl functions that are nested inside other functions in the expression.\n\n@refimpl f(x) = begin println(\"ref f\"); return mysin(x)^2 end\nf(x) = begin println(\"f\"); return mysin(x)^2 end\n\n# call the reference implementation\n@refimpl f(0.)  # prints \"ref f\", \"ref mysin\"\nf(0.)        # prints \"f\", \"mysin\"\n\nYou can target individual functions to be replaced with their reference implementation by passing that function after @refimpl.\n\n@refimpl mysin f(0.)  # prints \"fast f\", \"ref mysin\"\n@refimpl f f(0.)  # prints \"ref f\", \"fast mysin\"\n\n\n\n\n\n","category":"macro"}]
}
